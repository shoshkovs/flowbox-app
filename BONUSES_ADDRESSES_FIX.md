# Исправление проблемы с потерей бонусов и адресов после деплоя

## Проблема

После деплоя у пользователей слетали бонусы (становились 0) и сохраненные адреса (становились пустым массивом).

**Причина:** Фронт получал от бэкенда пустые/дефолтные значения (0 бонусов, [] адресов) и сразу же сохранял их обратно на сервер, перезаписывая реальные данные.

## Исправления

### 1. Фронтенд (`public/app.js`)

#### 1.1. Убрано автоматическое сохранение из `updateBonusesDisplay()`

**Было:**
```javascript
function updateBonusesDisplay() {
    // ... обновление DOM ...
    const userId = getUserId();
    if (userId) {
        saveUserData(); // ❌ Автоматическое сохранение при каждом обновлении UI
    }
}
```

**Стало:**
```javascript
function updateBonusesDisplay() {
    // ... обновление DOM ...
    // НЕ вызываем saveUserData() здесь!
    // Эта функция должна ТОЛЬКО обновлять DOM, а не сохранять данные на сервер.
}
```

**Результат:** Бонусы сохраняются только при реальных изменениях (после заказа, ручного редактирования), а не при каждом обновлении UI.

#### 1.2. Улучшена логика загрузки бонусов

**Было:**
```javascript
if (data.bonuses !== undefined) {
    accumulatedBonuses = data.bonuses; // Может быть 0 после деплоя
    updateBonusesDisplay(); // Вызывало saveUserData() и перезаписывало 0
}
```

**Стало:**
```javascript
if (data.bonuses !== undefined && data.bonuses !== null) {
    accumulatedBonuses = data.bonuses;
    updateBonusesDisplay(); // Только обновление UI, без сохранения
} else {
    // Если сервер не вернул бонусы, оставляем текущее значение в памяти
    console.log('⚠️ Сервер не вернул бонусы, оставляем текущее значение:', accumulatedBonuses);
}
```

**Результат:** Если сервер вернул 0 или не вернул бонусы, фронт не перезаписывает существующие значения.

### 2. Бэкенд (`bot.js`)

#### 2.1. Защита от перезаписи существующих бонусов нулем

**Было:**
```javascript
if (bonuses !== undefined && bonuses !== null) {
    // Обновляли бонусы без проверки на случай перезаписи нулем
    await client.query('UPDATE users SET bonuses = $1 WHERE id = $2', [bonuses, user.id]);
}
```

**Стало:**
```javascript
if (bonuses !== undefined && bonuses !== null) {
    const currentBonusValue = currentBonuses.rows[0]?.bonuses;
    
    // КРИТИЧЕСКАЯ ЗАЩИТА: Не перезаписываем существующие ненулевые бонусы нулем
    if (bonuses === 0 && currentBonusValue !== null && currentBonusValue !== undefined && currentBonusValue > 0) {
        console.log(`⚠️ ПРЕДОТВРАЩЕНА перезапись бонусов: было ${currentBonusValue}, пытались записать 0`);
        // Не обновляем бонусы, оставляем существующее значение
    } else if (currentBonusValue === null || currentBonusValue === undefined || currentBonusValue !== bonuses) {
        // Обновляем только если значение действительно изменилось
        await client.query('UPDATE users SET bonuses = $1 WHERE id = $2', [bonuses, user.id]);
    }
}
```

**Результат:** Если фронт отправил `bonuses: 0`, но в БД уже есть ненулевое значение, бэкенд не перезаписывает его.

#### 2.2. Защита от перезаписи существующих адресов пустым массивом

**Было:**
```javascript
if (addresses !== undefined && Array.isArray(addresses)) {
    await saveUserAddresses(user.id, addresses); // Могло перезаписать пустым массивом
}
```

**Стало:**
```javascript
if (addresses !== undefined && Array.isArray(addresses)) {
    const currentAddresses = await loadUserAddresses(user.id);
    
    // Если фронт отправил пустой массив, но в БД уже есть адреса - не перезаписываем
    if (addresses.length === 0 && currentAddresses.length > 0) {
        console.log(`⚠️ ПРЕДОТВРАЩЕНА перезапись адресов: было ${currentAddresses.length}, пытались записать 0`);
        // Не сохраняем пустой массив, оставляем существующие адреса
    } else {
        await saveUserAddresses(user.id, addresses);
    }
}
```

**Результат:** Если фронт отправил `addresses: []`, но в БД уже есть адреса, бэкенд не перезаписывает их.

**Примечание:** Функция `saveUserAddresses()` уже имела защиту от пустого массива (возвращала `true` без изменений), но теперь дополнительная проверка на уровне API endpoint предотвращает даже попытку сохранения.

## Когда данные сохраняются

Теперь `saveUserData()` вызывается **только** при реальных изменениях данных:

1. ✅ После успешного заказа (обновление бонусов, добавление заказа)
2. ✅ При добавлении/редактировании/удалении адреса
3. ✅ При изменении профиля (имя, телефон, email)
4. ✅ При изменении корзины (добавление/удаление товаров)

**НЕ вызывается:**
- ❌ При загрузке данных с сервера (`loadUserData()`)
- ❌ При обновлении UI (`updateBonusesDisplay()`, `loadSavedAddresses()`, `loadActiveOrders()`)
- ❌ При инициализации страницы

## Проверка после деплоя

После деплоя нужно убедиться:

1. **БД персистентная:** Данные не теряются при перезапуске сервера (PostgreSQL на постоянном диске, не in-memory)
2. **Миграции не дропают данные:** Миграции не содержат `DROP TABLE users/addresses` или обнуление полей `bonuses`
3. **Endpoint возвращает реальные данные:** `GET /api/user-data/:userId` читает бонусы и адреса из БД, а не возвращает дефолтные значения

## Логирование

Добавлено логирование для отслеживания попыток перезаписи:

- `⚠️ ПРЕДОТВРАЩЕНА перезапись бонусов` - когда фронт пытается записать 0 поверх существующих бонусов
- `⚠️ ПРЕДОТВРАЩЕНА перезапись адресов` - когда фронт пытается записать [] поверх существующих адресов
- `⚠️ Сервер не вернул бонусы` - когда сервер не вернул поле `bonuses` в ответе

Эти логи помогут диагностировать проблемы после деплоя.

