Кидаю файл, который можно сохранить как, например,
`CURSOR_STYLE.md` или `cursor-style.md` в корне **admin**-проекта.

Просто вставь содержимое в новый файл — и дальше в Cursor можно писать что-то вроде:
*«Делай изменения по правилам из CURSOR_STYLE.md»*.

---

````md
# FlowBox Admin – Style Guide для Cursor

Этот файл описывает, **как писать и менять код** в админке FlowBox.  
Cursor должен **строго** следовать этим правилам, если явно не сказано иначе.

---

## 0. Общие правила

1. **Ничего не ломать глобально без явной команды.**
   - Нельзя реорганизовывать всю структуру проекта, переименовывать папки, менять роуты или API-ендпоинты, если пользователь НЕ попросил это напрямую.
   - Любые большие рефакторинги – только по шагам и с объяснением плана в комментариях / описании PR.

2. **Изменяем код локально.**
   - Если задача про один экран, меняем только соответствующий `page.jsx` и связанные компоненты в `src/app/components`.
   - Не трогаем чужие модули, пока это не нужно для решения задачи.

3. **Поддерживаем существующий стиль.**
   - Если в файле уже есть конкретный стиль (форматирование, подход, хуки, способ работы с API и т.д.) – **подстраиваемся под него**, не придумываем новый.

4. **Комментарии и логирование.**
   - Для отладки использовать `console.log`/`console.error` с понятным префиксом:  
     `console.log('[customers][list] Loaded customers:', data);`
   - Комментарии короткие, по делу.  
     Комментарии на русском.

---

## 1. Технологический стек

- **Next.js (App Router)** – структура `/src/app/...`.
- **React** – только функциональные компоненты и хуки.
- **JavaScript + JSX** (не TypeScript, если в файле нет TS).
- Стили:
  - Если используются **Tailwind** – продолжаем в том же стиле.
  - Если используются **CSS/SCSS modules** – создаём рядом файл `*.module.css` и подключаем.
  - Если в компоненте уже есть подход к стилям – продолжаем его.

---

## 2. Структура проекта (admin)

Пример дерева (упрощённо):

- `src/app/`
  - `dashboard/page.jsx`
  - `analytics/page.jsx`
  - `orders/page.jsx`
  - `orders/[id]/page.jsx`
  - `customers/page.jsx`
  - `customers/[id]/page.jsx`
  - `products/page.jsx`
  - `products/[id]/page.jsx`
  - `products/new/page.jsx`
  - `warehouse/page.jsx`
  - `warehouse/new/page.jsx`
  - `delivery/page.jsx`
  - `settings/page.jsx`
  - `layout.jsx`
- `src/app/components/`
  - общие компоненты (таблицы, фильтры, формы и т.д.)

### Правило по структуре

1. **Список сущности**  
   `/src/app/<entity>/page.jsx`  
   Примеры:
   - `/analytics/page.jsx`
   - `/orders/page.jsx`
   - `/customers/page.jsx`
   - `/products/page.jsx`

2. **Детальная страница сущности**  
   `/src/app/<entity>/[id]/page.jsx`  
   Примеры:
   - `/orders/[id]/page.jsx`
   - `/customers/[id]/page.jsx`
   - `/products/[id]/page.jsx`

3. **Создание новой сущности**  
   `/src/app/<entity>/new/page.jsx`  
   Примеры:
   - `/products/new/page.jsx`
   - `/warehouse/new/page.jsx`

4. Общие, переиспользуемые части – в  
   `src/app/components/...`. Если компонент может пригодиться на других страницах – выносим его туда.

---

## 3. Именование и структура компонентов

### Компоненты

- Имя компонента = **PascalCase**:  
  `CustomerList`, `OrderDetails`, `ProductsTable`.
- Один файл = один основной компонент по умолчанию `export default`.

Пример:

```jsx
// src/app/orders/page.jsx
'use client';

import OrdersTable from '@/app/components/orders/OrdersTable';

export default function OrdersPage() {
  return (
    <main className="page">
      <h1 className="page-title">Заказы</h1>
      <OrdersTable />
    </main>
  );
}
````

### Пропсы

* Пропсы в компоненте – **объектом**, не более 3–5 пропсов.
  Если пропсов становится слишком много – группируем в объект.

```jsx
function OrdersTable({ orders, isLoading, onRowClick }) { ... }
```

---

## 4. Работа с данными и API

### Общие принципы

1. Все вызовы к backend FlowBox должны:

   * использовать существующие роуты API;
   * не менять формат ответа/запроса без явного указания пользователя.

2. Если в файле уже есть способ получения данных (через `fetch`, `axios`, `useSWR` и т.п.) – **используем тот же подход**.

3. Для новых экранов по умолчанию:

   * Делаем `fetch` из `useEffect`, если компонент клиентский (`'use client'`).
   * Храним данные в `useState`.
   * Обязательно обрабатываем состояние `loading` и `error`.

### Пример шаблона загрузки данных

```jsx
'use client';

import { useEffect, useState } from 'react';

export default function CustomersPage() {
  const [customers, setCustomers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function loadCustomers() {
      try {
        setLoading(true);
        setError(null);

        const res = await fetch('/api/admin/customers');
        if (!res.ok) {
          throw new Error('Failed to load customers');
        }

        const data = await res.json();
        setCustomers(data.customers || []);
      } catch (err) {
        console.error('[customers][list] error:', err);
        setError('Не удалось загрузить клиентов');
      } finally {
        setLoading(false);
      }
    }

    loadCustomers();
  }, []);

  // ...рендер
}
```

---

## 5. UI, верстка, стили

1. **Аккуратная типографика и отступы.**

   * Использовать существующие utility-классы (если Tailwind), либо класс-обёртку из имеющегося CSS.
   * Не плодить новые инлайновые стили без необходимости.

2. **Адаптивность.**

   * Админка должна быть читаемой минимум на обычном ноутбуке (ширина ~1280px).
   * Если добавляется таблица — не делать фиксированных ширин, которые ломают верстку.

3. **Компоненты интерфейса.**

   * Если в `src/app/components` уже есть табличный компонент, фильтры, селекты и т.п. — **используем их**, а не пишем с нуля.

4. **Иконки.**

   * Если уже используется какой-то пакет иконок / набор SVG – держимся его.
   * Новые иконки делать через существующий подход (inline SVG, React-компонент и т.п.).

---

## 6. Таблицы, фильтры, пагинация

Если нужно сделать список (заказы, клиенты, товары):

1. В таблице должны быть:

   * Заголовок колонок.
   * Чёткое состояние `loading` / `empty` / `error`.
   * Клик по строке (если нужен) – опционально, но с понятным курсором и hover-состоянием.

2. Пагинация:

   * Если уже реализована в другом списке – переиспользовать / копировать подход.
   * Если нет – можно пока сделать простую «ленивую» загрузку (все данные разом) и добавить пагинацию позже.

---

## 7. Ошибки, empty-state и загрузка

Для каждого экрана списка или детальной страницы:

* **Loading**: скелетон или простой текст `"Загрузка..."`.
* **Empty state**: понятный текст типа `"Пока нет заказов"` / `"Клиенты ещё не добавлены"`.
* **Error state**: например `"Ошибка загрузки данных"` + `console.error` с подробной информацией.

---

## 8. Навигация и URL’ы

1. **Не менять существующие пути без прямой инструкции.**

   * `/admin/dashboard`
   * `/admin/orders`
   * `/admin/orders/[id]`
   * `/admin/customers`
   * `/admin/customers/[id]`
   * `/admin/products`
   * `/admin/products/new`
   * `/admin/products/[id]`
   * `/admin/warehouse`
   * `/admin/warehouse/new`
   * `/admin/delivery`
   * `/admin/settings`

2. Для переходов внутри админки:

   * использовать `next/link` и относительные пути;
   * не хардкодить полный домен.

Пример:

```jsx
import Link from 'next/link';

<Link href={`/orders/${order.id}`}>
  <a className="table-row-link">Подробнее</a>
</Link>
```

---

## 9. Код-стайл

1. **Форматирование**

   * Использовать стандартный формат Prettier / VSCode (2 пробела / 4 — как уже в проекте).
   * Не миксовать табы и пробелы.

2. **Строки**

   * Одинарные кавычки `'...'` по умолчанию (если в файле уже так).

3. **Импорты**

   * Группировать: сначала React/Next, затем внешние библиотеки, затем локальные модули.
   * Не оставлять неиспользуемых импортов.

Пример:

```jsx
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';

import OrdersTable from '@/app/components/orders/OrdersTable';
import { fetchOrders } from '@/app/lib/api/orders';
```

---

## 10. Что делать Cursor НЕ должен

1. Не удалять и не менять существующий код **только ради красоты**, если он работает и явно не просили его переписать.
2. Не создавать новых корневых папок (типа `src/newApp`, `src/legacy`) без указания.
3. Не трогать код Telegram-бота, мини-аппа и backend-серверов — этот стайлгайд относится к **админке** (папка `admin`).

---

## 11. Как пользоваться этим файлом (для Cursor)

При любой задаче Cursor должен:

1. Сначала посмотреть этот файл и понять контекст.
2. Определить:

   * какой экран или компонент нужно изменить;
   * какие файлы с ним связаны.
3. Предложить изменения **только в нужных файлах**, соблюдая:

   * структуру роутов;
   * стиль компонента;
   * подход к API;
   * UI-паттерны.

